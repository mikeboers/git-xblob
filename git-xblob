#!/usr/bin/env python
"""
usage: git xblob init
   or: git xblob add <path>
   or: git xblob sync

"""
__doc__ = __doc__.strip()


import errno
import hashlib
import os
import re
import shlex
import shutil
import subprocess
import sys
import tempfile
import urllib
import urlparse


if len(sys.argv) < 2:
    print __doc__
    exit(1)


def do_init():

    # Determine if the HEAD exists.
    proc = subprocess.Popen(
        ['git', 'rev-parse', '--verify', 'HEAD'],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )
    head_exists = not proc.wait()

    # Make sure that the working dir is clean.
    if head_exists:
        git_status = subprocess.check_output(['git', 'status', '-uno', '--porcelain'])
        if git_status.strip():
            print 'Working directory is not clean.'
            print 'Please commit or stash your changes before initializing git-xblob.'
            return 2

    # Install user config.
    top_level = subprocess.check_output(['git', 'rev-parse', '--show-toplevel']).strip()
    config_path = os.path.join(top_level, '.gitxblobconfig')
    if os.path.exists(config_path):
        for line in open(config_path):
            line = line.strip()
            if not line:
                continue
            subprocess.call(['git', 'config'] + shlex.split(line))
    else:
        print 'Could not find .gitxblobconfig; skipping.'

    # Install our filters.
    subprocess.call(['git', 'config', 'filter.xblob.clean', 'git-xblob clean'])
    subprocess.call(['git', 'config', 'filter.xblob.smudge', 'git-xblob smudge'])

    # Force a re-clean.
    if head_exists:
        subprocess.call(['git', 'checkout', '-f', 'HEAD', '--', top_level])


def do_add():

    if len(sys.argv) < 3:
        print __doc__
        return 2

    paths = sys.argv[2:]

    missing_any = False
    for path in paths:
        if not os.path.exists(path):
            print path, 'does not exist'
            missing_any = True
    if missing_any:
        return 3

    for path in paths:

        # Add it to the attributes file.
        head, tail = os.path.split(path)

        attributes_path = os.path.join(head, '.gitattributes')
        with open(attributes_path, 'a') as fh:
            fh.write('%s filter=xblob\n' % tail)

        # Add the file and the attributes.
        subprocess.call(['git', 'add', '-f', attributes_path])
        subprocess.call(['git', 'add', '-f', path])


def do_clean():

    tmp_file = tempfile.NamedTemporaryFile(delete=False)
    try:

        # Save the contents to a temporary file, and hash it as we go.
        hash_ = hashlib.sha1()
        while True:
            chunk = sys.stdin.read(8096)
            if not chunk:
                break
            hash_.update(chunk)
            tmp_file.write(chunk)
        digest = hash_.hexdigest().lower()
        tmp_file.close()

        # Save the content into .git/xblobs
        git_path = subprocess.check_output(['git', 'rev-parse', '--git-dir']).strip()
        xblob_path = os.path.join(git_path, 'xblobs', digest[:2], digest[2:])
        if not os.path.exists(xblob_path):
            try:
                os.makedirs(os.path.dirname(xblob_path))
            except OSError as e:
                if e.errno != errno.EEXIST:
                    raise
            shutil.copyfile(tmp_file.name, xblob_path)

        print 'git-xblob:', digest

    finally:
        os.unlink(tmp_file.name)


def do_smudge():

    content = sys.stdin.read(1024)
    m = re.match(r'^git-xblob: ([\da-f]+)\s*$', content)

    # Pass it through if it doesn't match.
    if not m:
        sys.stdout.write(content)
        while True:
            chunk = sys.stdin.read(8096)
            if not chunk:
                return 0
            sys.stdout.write(chunk)

    digest = m.group(1).lower()
    git_path = subprocess.check_output(['git', 'rev-parse', '--git-dir']).strip()
    xblob_path = os.path.join(git_path, 'xblobs', digest[:2], digest[2:])

    if not os.path.exists(xblob_path):

        print >> sys.stderr, 'git-xblob: getting', digest
        
        if not os.path.exists(xblob_path):
            try:
                os.makedirs(os.path.dirname(xblob_path))
            except OSError as e:
                if e.errno != errno.EEXIST:
                    raise

        raw_get_uri = subprocess.check_output(['git', 'config', 'xblob.get']).strip()
        get_uri = urlparse.urlsplit(raw_get_uri)

        '''
        >>> urlsplit('http://files.mikeboers.com/xblob-sandbox')
        SplitResult(scheme='http', netloc='files.mikeboers.com', path='/xblob-sandbox', query='', fragment='')
        '''
        if get_uri.scheme in ('http', 'https'):

            xblob_url = '%s/%s/%s' % (raw_get_uri.strip('/'), digest[:2], digest[2:])

            response = urllib.urlopen(xblob_url)
            if response.getcode() != 200:
                print >> sys.stderr, 'HTTP %s from %s' % (response.getcode(), xblob_url)
                return 3

            with open(xblob_path, 'w') as fh:
                while True:
                    chunk = response.read(8096)
                    if not chunk:
                        break
                    fh.write(chunk)

        else:
            print >> sys.stderr, 'unknown xblob.get scheme:', raw_get_uri

    with open(xblob_path) as fh:
        while True:
            chunk = fh.read(8096)
            if not chunk:
                break
            sys.stdout.write(chunk)


def do_sync():

    git_path = subprocess.check_output(['git', 'rev-parse', '--git-dir']).strip()
    xblob_dir = os.path.join(git_path, 'xblobs')

    raw_put_uri = subprocess.check_output(['git', 'config', 'xblob.put']).strip()
    put_uri = urlparse.urlsplit(raw_put_uri)

    # urlsplit('scp:mikeboers.com:/srv/mikeboers.com/files/xblob-sandbox')
    # SplitResult(scheme='scp', netloc='', path='mikeboers.com:/srv/mikeboers.com/files/xblob-sandbox', query='', fragment='')    '''
    
    if put_uri.scheme == 'rsync':
        subprocess.call(['rsync', '-avx', 
            xblob_dir.rstrip('/') + '/',
            put_uri.path.rstrip('/') + '/',
        ])

    else:
        print 'unknown xblob.put scheme:', raw_put_uri













command_name = sys.argv[1]
command_func = globals().get('do_%s' % command_name)
if not command_func:
    print __doc__
    exit(1)

exit(command_func())


