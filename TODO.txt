
- consider adding an encryption key, and then encrypting with pytomcrypt
    `xblob.encryptionkey abcdef`

- don't add the same path multiple times to .gitattributes

- how to deal with spaces in .gitattributes? The only thing I have found
  is to put a question mark in there (which matches any character).

- `git xblob get <pattern>`
- `git xblob add --glob` allows patterns instead of names

- add leading slash to names in .gitattributes so that it refers to
  specific files

- replace spaces with a question mark, and warn the user

- eefactor into packages and modules
    - Python entrypoint for `git-xblob`

- Switch to "PUTting" files immediately, instead of waiting for a sync.

- Stub files should be allowed to contain any content. On the clean pass, they
  should return the same content that is already in the repo as long as the hash
  is the same. `git xblob regen` could forcibly regenerate it all.

  `git show HEAD:"hello.txt"` shows the current version of the file.

---

- Config files: .gitxblobconfig

  This is roughly INI style:

    [xblob]
    geturl = ...
    puturl = ...
    encrypted = true

  Walk up from the current directory merging until you are beside .git.

  Use http://docs.python.org/2/library/configparser.html: can likely
  use the builtin methods to do all the reading.

- Link files: .gitxblobx
  This is roughtly the git tree format:
      100644 xblob <hash> <path>

- Add to .gitignore:

  # git-xblob linked files
  /path/to/a
  /path/to/b

  - Search for r'# git-xblob[^\n]*\n([^\n]+\n)', and replace it with the
    new list. Add it to the end if it cannot be found.

- Several upload/download classes:
  - http(s)
  - ssh
  - s3
  - dropbox (maybe not possible)
  - files

  - They look in `git config` for their secrets if not provided. This allows
    `git xblob init` to ask for the secrets and save them there.


- Encryption

  - Files on the server are encrypted.
  - Files in .git/xblob/objects are encrypted.
  - .gitxblobs is encrypted.

  - This isn't really nessesary if the files are private, and we don't
    care about potential leaks via hash of file contents or file names.
